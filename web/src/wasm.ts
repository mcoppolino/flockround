// Generated by wasm-pack during `npm run wasm:build:*`.
import initWasm, {
  Sim,
  wasm_loaded_message,
} from "../../sim-wasm/pkg/sim_wasm.js";

export interface SimBoidsConfig {
  sepWeight: number;
  alignWeight: number;
  cohWeight: number;
  neighborRadius: number;
  separationRadius: number;
  minSpeed: number;
  maxSpeed: number;
  maxForce: number;
  mathMode?: SimMathMode;
  maxNeighborsSampled?: number;
  activeCount?: number;
  drag?: number;
  minDistance?: number;
  hardMinDistance?: number;
  jitterStrength?: number;
}

export type SimMathMode = "accurate" | "fast";
export type SimModelKind =
  | "classic"
  | "flock2-social"
  | "flock2-social-flight"
  | "f2-lite-social"
  | "f2-lite-social-flight";

export interface Flock2SocialConfig {
  avoidWeight: number;
  alignWeight: number;
  cohesionWeight: number;
  boundaryWeight: number;
  boundaryCount: number;
  neighborRadius: number;
  topologicalNeighbors: number;
  fieldOfViewDeg: number;
}

export interface Flock2FlightConfig {
  reactionTimeMs: number;
  dynamicStability: number;
  mass: number;
  wingArea: number;
  liftFactor: number;
  dragFactor: number;
  thrust: number;
  minSpeed: number;
  maxSpeed: number;
  gravity: number;
  airDensity: number;
}

export interface ClassicModelConfig {
  mathMode: SimMathMode;
  maxNeighborsSampled: number;
  maxForce: number;
  drag: number;
  minDistance: number;
  hardMinDistance: number;
  jitterStrength: number;
}

const MAX_BIRD_CAPACITY = 10_000;

function randomSeed32(): number {
  const bytes = new Uint32Array(1);
  crypto.getRandomValues(bytes);
  return bytes[0];
}

export class WasmSimClient {
  private readonly sim: Sim;
  private readonly wasmMemory: WebAssembly.Memory;
  private positionsView: Float32Array;
  private depthView: Float32Array;
  private headingView: Float32Array;
  private memoryBuffer: ArrayBuffer;
  private readonly positionsPointer: number;
  private readonly positionsLength: number;
  private readonly depthPointer: number;
  private readonly depthLength: number;
  private readonly headingPointer: number;
  private readonly headingLength: number;

  constructor(
    count: number,
    seed: number,
    width: number,
    height: number,
    wasmMemory: WebAssembly.Memory,
  ) {
    this.sim = new Sim(count, seed, width, height);
    this.wasmMemory = wasmMemory;
    this.positionsPointer = this.sim.render_xy_ptr();
    this.positionsLength = this.sim.render_xy_len();
    this.depthPointer = this.sim.render_z_ptr();
    this.depthLength = this.sim.render_z_len();
    this.headingPointer = this.sim.render_heading_xy_ptr();
    this.headingLength = this.sim.render_heading_xy_len();
    this.memoryBuffer = wasmMemory.buffer;
    this.positionsView = new Float32Array(
      this.memoryBuffer,
      this.positionsPointer,
      this.positionsLength,
    );
    this.depthView = new Float32Array(
      this.memoryBuffer,
      this.depthPointer,
      this.depthLength,
    );
    this.headingView = new Float32Array(
      this.memoryBuffer,
      this.headingPointer,
      this.headingLength,
    );
  }

  step(dt: number): void {
    this.sim.step(dt);
    this.refreshViewIfMemoryChanged();
  }

  setConfig(config: SimBoidsConfig): void {
    this.sim.set_config(
      config.sepWeight,
      config.alignWeight,
      config.cohWeight,
      config.neighborRadius,
      config.separationRadius,
      config.minSpeed,
      config.maxSpeed,
      config.maxForce,
    );

    if (config.mathMode) {
      this.setMathMode(config.mathMode);
    }
    if (config.maxNeighborsSampled !== undefined) {
      this.setMaxNeighborsSampled(config.maxNeighborsSampled);
    }
    if (config.activeCount !== undefined) {
      this.setActiveCount(config.activeCount);
    }
    if (config.drag !== undefined) {
      this.setDrag(config.drag);
    }
    if (config.minDistance !== undefined) {
      this.setMinDistance(config.minDistance);
    }
    if (config.hardMinDistance !== undefined) {
      this.setHardMinDistance(config.hardMinDistance);
    }
    if (config.jitterStrength !== undefined) {
      this.setJitterStrength(config.jitterStrength);
    }
  }

  setBounds(width: number, height: number): void {
    this.sim.set_bounds(width, height);
  }

  setBounceBounds(enabled: boolean): void {
    this.sim.set_bounce_bounds(enabled);
  }

  isBounceBoundsEnabled(): boolean {
    return this.sim.bounce_bounds();
  }

  setAxisBounce(bounceX: boolean, bounceY: boolean, bounceZ: boolean): void {
    this.sim.set_axis_bounce(bounceX, bounceY, bounceZ);
  }

  isBounceXEnabled(): boolean {
    return this.sim.bounce_x();
  }

  isBounceYEnabled(): boolean {
    return this.sim.bounce_y();
  }

  isBounceZEnabled(): boolean {
    return this.sim.bounce_z();
  }

  setMathMode(mode: SimMathMode): void {
    this.sim.set_math_mode(mode === "fast" ? 1 : 0);
  }

  setModelKind(kind: SimModelKind): void {
    const kindId =
      kind === "flock2-social"
        ? 1
        : kind === "flock2-social-flight"
          ? 2
          : kind === "f2-lite-social"
            ? 3
            : kind === "f2-lite-social-flight"
              ? 4
              : 0;
    this.sim.set_model_kind(kindId);
  }

  getModelKind(): SimModelKind {
    const kindId = this.sim.model_kind();
    switch (kindId) {
      case 1:
        return "flock2-social";
      case 2:
        return "flock2-social-flight";
      case 3:
        return "f2-lite-social";
      case 4:
        return "f2-lite-social-flight";
      default:
        return "classic";
    }
  }

  setClassicConfig(config: ClassicModelConfig): void {
    this.sim.set_classic_config(
      config.mathMode === "fast" ? 1 : 0,
      Math.max(0, Math.floor(config.maxNeighborsSampled)),
      Math.max(0, config.maxForce),
      Math.max(0, config.drag),
      Math.max(0, config.minDistance),
      Math.max(0, config.hardMinDistance),
      Math.max(0, config.jitterStrength),
    );
  }

  setFlock2SocialConfig(config: Flock2SocialConfig): void {
    this.sim.set_flock2_social_config(
      config.avoidWeight,
      config.alignWeight,
      config.cohesionWeight,
      config.boundaryWeight,
      config.boundaryCount,
      config.neighborRadius,
      Math.max(1, Math.floor(config.topologicalNeighbors)),
      config.fieldOfViewDeg,
    );
  }

  setFlock2FlightConfig(config: Flock2FlightConfig): void {
    this.sim.set_flock2_flight_config(
      config.reactionTimeMs,
      config.dynamicStability,
      config.mass,
      config.wingArea,
      config.liftFactor,
      config.dragFactor,
      config.thrust,
      config.minSpeed,
      config.maxSpeed,
      config.gravity,
      config.airDensity,
    );
  }

  getMathMode(): SimMathMode {
    return this.sim.math_mode() === 1 ? "fast" : "accurate";
  }

  setMaxNeighborsSampled(maxNeighbors: number): void {
    this.sim.set_max_neighbors_sampled(Math.max(0, Math.floor(maxNeighbors)));
  }

  getMaxNeighborsSampled(): number {
    return this.sim.max_neighbors_sampled();
  }

  getNeighborsVisitedLastStep(): number {
    return this.sim.neighbors_visited_last_step();
  }

  setMaxForce(maxForce: number): void {
    this.sim.set_max_force(Math.max(0, maxForce));
  }

  getMaxForce(): number {
    return this.sim.max_force();
  }

  setDrag(drag: number): void {
    this.sim.set_drag(Math.max(0, drag));
  }

  getDrag(): number {
    return this.sim.drag();
  }

  setShapeAttractorWeight(weight: number): void {
    this.sim.set_shape_attractor_weight(Math.max(0, weight));
  }

  getShapeAttractorWeight(): number {
    return this.sim.shape_attractor_weight();
  }

  setShapePoints(pointsXyz: Float32Array): void {
    this.sim.set_shape_points_xyz(pointsXyz);
  }

  setMinDistance(minDistance: number): void {
    this.sim.set_min_distance(Math.max(0, minDistance));
  }

  getMinDistance(): number {
    return this.sim.min_distance();
  }

  setHardMinDistance(minDistance: number): void {
    this.sim.set_hard_min_distance(Math.max(0, minDistance));
  }

  getHardMinDistance(): number {
    return this.sim.hard_min_distance();
  }

  setJitterStrength(jitterStrength: number): void {
    this.sim.set_jitter_strength(Math.max(0, jitterStrength));
  }

  getJitterStrength(): number {
    return this.sim.jitter_strength();
  }

  setZMode(enabled: boolean): void {
    this.sim.set_z_mode(enabled);
  }

  isZModeEnabled(): boolean {
    return this.sim.z_mode_enabled();
  }

  setZForceScale(scale: number): void {
    this.sim.set_z_force_scale(scale);
  }

  getCount(): number {
    return this.sim.count();
  }

  setActiveCount(activeCount: number): void {
    this.sim.set_active_count(Math.max(0, Math.floor(activeCount)));
  }

  getActiveCount(): number {
    return this.sim.active_count();
  }

  getPositions(): Float32Array {
    this.refreshViewIfMemoryChanged();
    return this.positionsView;
  }

  getDepth(): Float32Array {
    this.refreshViewIfMemoryChanged();
    return this.depthView;
  }

  getHeading(): Float32Array {
    this.refreshViewIfMemoryChanged();
    return this.headingView;
  }

  getPointer(): number {
    return this.positionsPointer;
  }

  getDepthPointer(): number {
    return this.depthPointer;
  }

  getHeadingPointer(): number {
    return this.headingPointer;
  }

  private refreshViewIfMemoryChanged(): void {
    if (this.memoryBuffer === this.wasmMemory.buffer) {
      return;
    }

    this.memoryBuffer = this.wasmMemory.buffer;
    this.positionsView = new Float32Array(
      this.memoryBuffer,
      this.positionsPointer,
      this.positionsLength,
    );
    this.depthView = new Float32Array(
      this.memoryBuffer,
      this.depthPointer,
      this.depthLength,
    );
    this.headingView = new Float32Array(
      this.memoryBuffer,
      this.headingPointer,
      this.headingLength,
    );
  }
}

export async function initWasmModule(): Promise<WasmSimClient> {
  const wasm = await initWasm();
  console.log(wasm_loaded_message());

  const seed = randomSeed32();
  const sim = new WasmSimClient(MAX_BIRD_CAPACITY, seed, 1.0, 1.0, wasm.memory);
  console.log("Sim ready", {
    count: sim.getCount(),
    seed,
    ptr: sim.getPointer(),
    depthPtr: sim.getDepthPointer(),
    headingPtr: sim.getHeadingPointer(),
  });

  return sim;
}
